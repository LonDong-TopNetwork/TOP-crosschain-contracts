[1mdiff --git a/contracts/contracts/Top/ERC20MintProxy.sol b/contracts/contracts/Top/ERC20MintProxy.sol[m
[1mindex bd13e6a..fd1de9e 100644[m
[1m--- a/contracts/contracts/Top/ERC20MintProxy.sol[m
[1m+++ b/contracts/contracts/Top/ERC20MintProxy.sol[m
[36m@@ -6,7 +6,7 @@[m [mimport "../common/TransferedQuotas.sol";[m
 import "../common/ERC20Mint.sol";[m
 import "./prove/IProver.sol";[m
 import "./verify/VerifierUpgradeable.sol";[m
[31m-import "hardhat/console.sol";[m
[32m+[m[32m//import "hardhat/console.sol";[m
 [m
 contract ERC20MintProxy is VerifierUpgradeable, TransferedQuotas {[m
     event Burned ([m
[1mdiff --git a/contracts/contracts/Top/TRC20.sol b/contracts/contracts/Top/TRC20.sol[m
[1mindex 4f52672..8e7959b 100644[m
[1m--- a/contracts/contracts/Top/TRC20.sol[m
[1m+++ b/contracts/contracts/Top/TRC20.sol[m
[36m@@ -27,7 +27,7 @@[m [mcontract TRC20 is ERC20, VerifierUpgradeable, TransferedQuotas {[m
         address _peerProxyHash,[m
         address _peerAssetHash,[m
         uint64 _minBlockAcceptanceHeight,[m
[31m-        string memory _name, [m
[32m+[m[32m        string memory _name,[m
         string memory _symbol[m
     ) ERC20(_name, _symbol) {[m
         _TRC20_init(_prover, _peerProxyHash, _peerAssetHash, _minBlockAcceptanceHeight);[m
[1mdiff --git a/contracts/contracts/Top/codec/EthProofDecoder.sol b/contracts/contracts/Top/codec/EthProofDecoder.sol[m
[1mindex 45a5fac..4676ccf 100644[m
[1m--- a/contracts/contracts/Top/codec/EthProofDecoder.sol[m
[1m+++ b/contracts/contracts/Top/codec/EthProofDecoder.sol[m
[36m@@ -2,7 +2,7 @@[m
 pragma solidity ^0.8.0;[m
 [m
 import "../../common/Borsh.sol";[m
[31m-import "hardhat/console.sol";[m
[32m+[m[32m// import "hardhat/console.sol";[m
 [m
 library EthProofDecoder {[m
     using Borsh for Borsh.Data;[m
[1mdiff --git a/contracts/contracts/Top/prove/Prover.sol b/contracts/contracts/Top/prove/Prover.sol[m
[1mindex e76048d..f86765a 100644[m
[1m--- a/contracts/contracts/Top/prove/Prover.sol[m
[1m+++ b/contracts/contracts/Top/prove/Prover.sol[m
[36m@@ -3,7 +3,7 @@[m [mpragma solidity ^0.8.0;[m
 [m
 import "./IProver.sol";[m
 import "../../../lib/lib/MPT.sol";[m
[31m-import "hardhat/console.sol";[m
[32m+[m[32m//import "hardhat/console.sol";[m
 [m
 contract Prover is IProver{[m
     using MPT for MPT.MerkleProof;[m
[1mdiff --git a/contracts/contracts/Top/verify/VerifierUpgradeable.sol b/contracts/contracts/Top/verify/VerifierUpgradeable.sol[m
[1mindex e7f6606..a06fc66 100644[m
[1m--- a/contracts/contracts/Top/verify/VerifierUpgradeable.sol[m
[1m+++ b/contracts/contracts/Top/verify/VerifierUpgradeable.sol[m
[36m@@ -2,7 +2,7 @@[m
 pragma solidity ^0.8.0;[m
 import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";[m
 import "../prove/IProver.sol";[m
[31m-// import "hardhat/console.sol";[m
[32m+[m[32mimport "hardhat/console.sol";[m
 abstract contract VerifierUpgradeable is Initializable {[m
     using Borsh for Borsh.Data;[m
     using EthProofDecoder for Borsh.Data;[m
[36m@@ -61,16 +61,14 @@[m [mabstract contract VerifierUpgradeable is Initializable {[m
         (_receipt.data, contractAddress) = _parseLog(proof.logEntryData);[m
         require(contractAddress != address(0), "Invalid Token lock address");[m
         require(lockProxyHash == contractAddress, "proxy is not bound");[m
[31m-[m
         EthereumDecoder.TransactionReceiptTrie memory receipt = EthereumDecoder.toReceipt(proof.reciptData);[m
         EthereumDecoder.BlockHeader memory header = EthereumDecoder.toBlockHeader(proof.headerData);[m
         bytes memory reciptIndex = abi.encode(header.number, proof.reciptIndex);[m
         bytes32 proofIndex = keccak256(reciptIndex);[m
[31m-        [m
[31m-        require(!usedProofs[proofIndex], "The burn event proof cannot be reused");[m
[32m+[m
         (bool success,) = prover.verify(proof, receipt, header);[m
         require(success, "Proof should be valid");[m
[31m-        [m
[32m+[m[32m        require(!usedProofs[proofIndex], "The burn event proof cannot be reused");[m
         _receipt.proofIndex = proofIndex;[m
     }[m
 [m
[1mdiff --git a/contracts/contracts/common/Borsh.sol b/contracts/contracts/common/Borsh.sol[m
[1mindex af38978..9cc8c34 100644[m
[1m--- a/contracts/contracts/common/Borsh.sol[m
[1m+++ b/contracts/contracts/common/Borsh.sol[m
[36m@@ -1,8 +1,8 @@[m
 // SPDX-License-Identifier: GPL-3.0-or-later[m
[31m-pragma solidity ^0.8;[m
[32m+[m[32mpragma solidity ^0.8.0;[m
 [m
 import "./Utils.sol";[m
[31m-import "hardhat/console.sol";[m
[32m+[m[32m//import "hardhat/console.sol";[m
 [m
 library Borsh {[m
     using Borsh for Data;[m
[1mdiff --git a/contracts/contracts/common/TransferedQuata.sol b/contracts/contracts/common/TransferedQuata.sol[m
[1mindex 5feb842..386f8ed 100644[m
[1m--- a/contracts/contracts/common/TransferedQuata.sol[m
[1m+++ b/contracts/contracts/common/TransferedQuata.sol[m
[36m@@ -1,5 +1,5 @@[m
 // SPDX-License-Identifier: GPL-3.0-or-later[m
[31m-pragma solidity ^0.8;[m
[32m+[m[32mpragma solidity ^0.8.0;[m
 [m
 import "./AdminControlledUpgradeable.sol";[m
 [m
[1mdiff --git a/contracts/contracts/common/TransferedQuotas.sol b/contracts/contracts/common/TransferedQuotas.sol[m
[1mindex 313c770..c2ccfde 100644[m
[1m--- a/contracts/contracts/common/TransferedQuotas.sol[m
[1m+++ b/contracts/contracts/common/TransferedQuotas.sol[m
[36m@@ -1,5 +1,5 @@[m
 // SPDX-License-Identifier: GPL-3.0-or-later[m
[31m-pragma solidity ^0.8;[m
[32m+[m[32mpragma solidity ^0.8.0;[m
 [m
 import "./AdminControlledUpgradeable.sol";[m
 [m
[1mdiff --git a/contracts/contracts/common/Utils.sol b/contracts/contracts/common/Utils.sol[m
[1mindex 8a6fa2f..2133245 100644[m
[1m--- a/contracts/contracts/common/Utils.sol[m
[1m+++ b/contracts/contracts/common/Utils.sol[m
[36m@@ -1,5 +1,5 @@[m
 // SPDX-License-Identifier: GPL-3.0-or-later[m
[31m-pragma solidity ^0.8;[m
[32m+[m[32mpragma solidity ^0.8.0;[m
 [m
 library Utils {[m
     function swapBytes2(uint16 v) internal pure returns (uint16) {[m
[1mdiff --git a/contracts/lib/lib/EthereumDecoder.sol b/contracts/lib/lib/EthereumDecoder.sol[m
[1mindex b5a64e7..0299c29 100644[m
[1m--- a/contracts/lib/lib/EthereumDecoder.sol[m
[1m+++ b/contracts/lib/lib/EthereumDecoder.sol[m
[36m@@ -3,7 +3,7 @@[m [mpragma solidity ^0.8.0;[m
 [m
 import "../external_lib/RLPEncode.sol";[m
 import "../external_lib/RLPDecode.sol";[m
[31m-import "hardhat/console.sol";[m
[32m+[m[32m//import "hardhat/console.sol";[m
 [m
 library EthereumDecoder {[m
     using RLPDecode for RLPDecode.RLPItem;[m
[36m@@ -196,7 +196,7 @@[m [mlibrary EthereumDecoder {[m
         uint byte0;[m
         RLPDecode.Iterator memory it;        [m
         assembly {[m
[31m-            byte0 := byte(0, mload(data))[m
[32m+[m[32m            byte0 := byte(0, mload(add(data, 0x20)))[m
         }[m
 [m
         if (byte0 <= 0x7f) {[m
[1mdiff --git a/tests/testexample.js b/tests/testexample.js[m
[1mindex e72d83a..f7d90e6 100644[m
[1m--- a/tests/testexample.js[m
[1m+++ b/tests/testexample.js[m
[36m@@ -623,12 +623,16 @@[m [mdescribe("TRC20", function () {[m
         proof = await getProof.receiptProof(tx.hash)[m
         rpcInstance = new rpc("http://127.0.0.1:8545")[m
         const block = await rpcInstance.eth_getBlockByHash(rc.blockHash, false)[m
[32m+[m[32m        console.log(block)[m
         let targetReceipt = await rpcInstance.eth_getTransactionReceipt(tx.hash)[m
         const re = Receipt.fromRpc(targetReceipt)[m
         const rlpLog = new LOGRLP(rc.logs[event.logIndex])[m
         const rlplog = Log.fromRpc(rlpLog)[m
 [m
         const value = new TxProof(event.logIndex, rlplog.buffer, event.transactionIndex, re.buffer, proof.header.buffer, proof.receiptProof)[m
[32m+[m[32m        const blockHash = keccak256(proof.header.buffer)[m
[32m+[m[32m        console.log(proof.header.buffer)[m
[32m+[m[32m        console.log(blockHash)[m
 [m
         const schema = new Map([[TxProof, {kind: 'struct', fields: [['logIndex', 'u64'], ['logEntryData', ['u8']], ['reciptIndex', 'u64'], ['reciptData', ['u8']], ['headerData', ['u8']], ['proof', [['u8']]]]}]])[m
         const buffer = borsh.serialize(schema, value);[m
